# 执行环境（execution context）
执行环境定义了变量或函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有一个与之关联的变量对象，**<font color='red'>环境中定义的所有变量和函数都保存在这个对象中</font>**。  

全局执行环境是最外围的一个执行环境。在web浏览器中，全局执行环境被认为是window对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。**<font color='red'>某个执行环境的所有代码执行完毕后，该环境被销毁，保存在其中的变量和函数定义也随之销毁（全局执行环境直到应用程序退出--例如关闭网页或浏览器--时才会被销毁）</font>**。

> 每个函数都有自己的执行环境。当执行流流如一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。  
>当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个在全局环境中是不存在的）。作用域链中的下一个变量对象来之包含（外部）环境，而在再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链的最后一个对象。  
> 标识符（变量）解析就是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。


# 作用域
* 变量声明，不管在哪里发生（声明），都会在任意代码执行前处理。
* 以var声明的变量的作用域就是当前执行上下文，即某个函数，或者全局作用域（声明在函数外）。
* 赋值给未声明的变量，当执行时会隐式创建全局变量（成为global的属性）

**<font color='red'>没有块级作用域</font>**  
Javascript中没有块级作用域（花括号）。<font color='red'>由于Javascript的变量作用域实际上是函数内部</font>，我们在```for```循环等语句块中是无法定义具有局部作用域的变量。
```javascript
function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    i += 100; // 仍然可以引用变量i
}
```

# ```this```
```this```关键词是Javascript中最令人疑惑的机制之一。```this```是非常特殊的关键词标识符，再每个函数的作用域中被自动创建。  
当函数被调用，一个活动对象(activation object)被创建，这个object包含：函数在哪调用(call-stack)，函数怎么调用，参数等等。object的一个属性就是```this```，指向函数执行期间的```this```对象。

* ```this```不是author-time binding，而是runtime binding。
* ```this```的上下文基于函数调用的情况。和函数在哪定义无关，而和函数怎么调用有关。

## ```this```在具体情况下的分析
### 1.Global context
在全局上下文（任何函数以外），```this```指向全局对象。
### 2.Function context
在函数内部是，```this```由函数怎么调用来确定
1. 简单调用，即独立函数调用。由于```this```没有通过```call```来指定，且```this```必须指向对象，那么默认就指向全局对象。
```java
function f1(){
    return this;
}
f1()===window;//global object
```
2. 当函数作为对象方法调用时，```this```指向该对象
```java
var o = {
    prop:27,
    f:function(){
        return this.prop;
    }
};
```
3. 构造函数
在构造函数（函数用new调用）中，this指向要被constructed的新对象。

4. call和apply
Function.prototype上的call和apply可以指定函数运行时的this。
```java
function add(c, d){
  return this.a + this.b + c + d;
}

var o = {a:1, b:3};
add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16
add.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34
```
注意，当用call和apply而传进去作为this的不是对象时，将会调用内置的ToObject操作转换成对象。所以4将会装换成new Number(4)，而null/undefined由于无法转换成对象，全局对象将作为this。